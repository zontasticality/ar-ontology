---
title: Efficient SMT Solving for Bit-Vectors and the Extensional Theory of Arrays
type: source
---

Paper Link: [Here](../papers/Efficient%20SMT%20Solving%20for%20Bit-Vectors%20and%20the%20Extensional%20Theory%20of%20Arrays.pdf)

## Summary

Summary generated by Gemini 2.5 Pro Preview 05-06:

The document focuses on "Efficient SMT Solving for Bit-Vectors and the Extensional Theory of Arrays" (page 1). It details both the theoretical underpinnings and practical implementation aspects, particularly within the SMT solver Boolector.

**I. Theory of Arrays (primarily from Chapter 2)**

1.  **Definition and Axioms (page 11, Section 2.2):**
    *   The document discusses the **extensional theory of arrays**, which allows reasoning about array elements and entire arrays (array equality).
    *   The signature ΣA includes `read`, `write`, and `=`.
    *   `read(a,i)` returns the value of array `a` at index `i`.
    *   `write(a,i,e)` returns a new array, identical to `a` except at index `i` where it holds element `e`.
    *   **McCarthy's Axioms** are fundamental:
        *   (A1) Congruence: `i = j ⇒ read(a,i) = read(a,j)`
        *   (A2) Read-over-write (same index): `i = j ⇒ read(write(a,i,e),j) = e`
        *   (A3) Read-over-write (different index): `i ≠ j ⇒ read(write(a,i,e),j) = read(a,j)`
    *   **Axiom of Extensionality** is crucial for array equality:
        *   (A4) `a = b ⇔ ∀i(read(a,i) = read(b,i))`
        *   An alternative form (A4') is given for quantifier-free contexts: `a ≠ b ⇔ ∃λ (read(a,λ) ≠ read(b,λ))`, meaning unequal arrays must differ at some witness index λ (page 12).
    *   The quantifier-free fragment is denoted `TA`.

2.  **Decision Procedure DPA (pages 17-33, Sections 2.6, 2.7):**
    *   A novel decision procedure `DPA` for the quantifier-free extensional theory of arrays combined with a base theory `TB` (e.g., bit-vectors) is presented.
    *   **Preprocessing (page 13, Section 2.4):**
        *   For each array inequality `a ≠ c`, a witness constraint based on (A4') is added: `a ≠ c → ∃λ. read(a,λ) ≠ read(c,λ)`.
        *   For each `write(a,i,e)`, the constraint `read(write(a,i,e),i) = e` (from A2) is added. These make the formula equisatisfiable (page 14).
    *   **Formula Abstraction (page 15, Section 2.5):** `read` operations are replaced by fresh abstraction variables, and array equalities by fresh propositional variables, creating an over-approximation `α(π)`.
    *   **Abstraction Refinement Loop (page 17, Section 2.6):**
        *   `DPB` (decision procedure for the base theory) solves `α(π) ∧ ξ` (where `ξ` are refinement lemmas).
        *   If a model `σ` is found, a **consistency checker** (page 18, Section 2.7) determines if `σ` corresponds to a valid model in `TA`.
        *   **Read Propagation (pages 21, 27):** A mapping `ρ` tracks reads associated with array terms. Reads are propagated:
            *   Downwards through writes (Rule D, page 21): If `σ(α(i)) ≠ σ(α(j))`, `read(b,i)` is propagated from `write(a,j,e)` to `a`.
            *   Across array equalities (Rules R, L, page 27): If `σ(α(a=c))` is true, reads are propagated between `a` and `c`.
            *   Upwards from arrays through writes (Rule U, page 27): If `σ(α(i)) ≠ σ(α(j))`, `read(b,i)` from `a` is propagated to `write(a,j,e)`. This respects axiom (A3).
        *   **Lemma Generation:** If an inconsistency (e.g., violation of adapted congruence axiom (A1), see page 22) is found, a lemma based on the propagation path conditions is generated and added to `ξ`. These lemmas are `TA`-valid (page 34, Section 2.8).
    *   The procedure is proven sound (page 34) and complete (page 39).
    *   Complexity: The number of lemmas is bounded by O(n² · 2ⁿ) (page 43).

3.  **Implementation Details for Arrays in Boolector:**
    *   **Treating Writes as Reads (page 47, Section 2.11.4; page 61):** A `write(a,i,e)` can be implicitly treated as a read on itself for index `i`, returning `e`. This avoids the explicit preprocessing step of adding `read(write(a,i,e),i)=e`.
    *   **Unconstrained Array Variables (page 75, Section 3.4.2):**
        *   `read(a,i)` where `a` is unconstrained is rewritten to a fresh variable.
        *   `write(a,i,v)` where `a` and `v` are unconstrained is rewritten to a fresh array variable.
        *   `a = t` where `a` is unconstrained is rewritten to a fresh boolean variable.

**II. Theory of Bit-Vectors (primarily from Chapter 3 and Appendix A)**

1.  **General Handling:**
    *   Boolector primarily uses **term rewriting and bit-blasting** for bit-vectors (page 62).
    *   The BTOR format supports bit-vector variables, constants (decimal, hex, binary), and operations with arbitrary bit-width (page 127, 129).
    *   Semantics largely follow SMT-LIB QF_BV (page 129).
    *   A key distinction: division by zero in BTOR results in the largest unsigned integer (page 129).

2.  **Under-Approximation Techniques (pages 65-68, Section 3.3):**
    *   Aimed at speeding up satisfiable instances and producing "smaller" models by restricting bit domains.
    *   **Techniques (page 66):**
        *   *Sign-extension:* Most significant bits are forced equal to the (n-1)th bit (last effective bit).
        *   *Zero-extension/One-extension:* Most significant bits are forced to 0 or 1.
        *   *Bit-partitioning:* Bits are partitioned into equivalence classes, with all bits in a class having the same value (page 67).
    *   **CNF Layer Implementation (page 67, Section 3.3.1):** Under-approximations are added as incremental clauses to the SAT solver, controlled by a fresh boolean assumption variable `e`. Refinement involves disabling `e` and introducing a new approximation with a new assumption variable (page 68).
    *   **Early Unsat Termination (page 69, Section 3.3.3):** If the under-approximated formula is unsatisfiable *without* using the assumption variable `e`, the original formula is unsatisfiable.

3.  **Unconstrained Bit-Vector Variables (page 72, Section 3.4.1):**
    *   If an operand `v` of a function `f` is unconstrained (appears only once) and `f` is "invertible" with respect to `v`, then `f(...)` can be replaced by a fresh bit-vector variable.
    *   Example: `v3 + t = v1 & v2`. If `v1`, `v2` are unconstrained, `v1 & v2` can be replaced by `v4`. If `v3` is unconstrained, `v3 + t` can be `v5`. The formula becomes `v4 = v5` (page 74).
    *   Corner cases exist (e.g., multiplication by an even constant, `v < 000`) where this is not sound (page 75).

4.  **Symbolic Overflow Detection (pages 77-84, Section 3.5):**
    *   Boolector directly supports symbolic overflow predicates for fixed-size bit-vector arithmetic (add, subtract, multiply, divide) in two's complement.
    *   **Addition (page 78):**
        *   *Unsigned:* Carry-out of MSB `c[n-1]` is 1. Implemented by adding operands extended with a 0-bit and checking the new MSB `r[n]`.
        *   *Signed:* (Operands have same sign) AND (result has different sign), or `c[n-1] ⊕ c[n-2]` (page 79).
    *   **Subtraction (page 79):** `a - b` as `a + (-b)`.
        *   *Unsigned:* Overflow if `c[n-1]` (from the addition `a + (-b)`) is 0.
        *   *Signed:* Defined by specific cases of operand signs and result sign.
    *   **Multiplication (page 80):** Considers an `n+1` bit product `r`.
        *   *Unsigned:* (Sum of leading zeros in `a` and `b`, `Za + Zb`) `< n-1` OR `r[n]` is 1. A "leading zeros examination principle" is detailed (Figure 3.8, page 81; formula page 82).
        *   *Signed:* (Sum of leading bits `L(a) + L(b)`) `< n` OR `r[n] ⊕ r[n-1]` is 1. A "leading bits examination principle" is detailed (Figure 3.9, page 83; formula page 84).
    *   **Division (page 84):**
        *   *Signed:* Overflow only if the smallest representable integer is divided by -1.
        *   *Unsigned:* Never overflows.

5.  **BTOR Format for Bit-Vectors (pages 129-131, Appendix A.2):**
    *   Lists unary (`not`, `neg`, `redand`, `inc`, etc.), binary (`and`, `add`, `mul`, `eq`, `sll`, `uaddo`, etc.), ternary (`cond`), and miscellaneous (`slice`) operators with their bit-width specifications.
    *   Includes Verilog reduction operators, VHDL rotate operators, and specific overflow detection operators (e.g., `umulo`).

This summary covers the main theoretical aspects of bit-vectors and arrays as presented in the dissertation, including their formal definitions, the decision procedures developed, and key implementation strategies related to these theories within Boolector.